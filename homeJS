const patternImages = [
  'https://your-image-1.jpg',
  'https://your-image-2.jpg',
  'https://your-image-3.jpg',
  
];;
    const count = Math.max(6, Math.floor(size / 12));
    for (let i = 0; i < count; i++) {
      const x = (Math.sin(i * 2.4) * 0.5 + 0.5) * size;
      const y = (Math.cos(i * 1.7) * 0.5 + 0.5) * size;
      const item = items[i % items.length];
      const s = size * 0.12;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(i * 0.9);
      ctx.fillStyle = item.color;
      if (item.type === 'leaf') {
        ctx.beginPath();
        ctx.ellipse(0, -s * 0.6, s * 0.28, s * 0.7, 0, 0, Math.PI * 2);
        ctx.fill();
      } else if (item.type === 'flower') {
        for (let p = 0; p < 5; p++) {
          ctx.save();
          ctx.rotate((p * Math.PI * 2) / 5);
          ctx.beginPath();
          ctx.ellipse(0, -s * 0.45, s * 0.22, s * 0.45, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        ctx.fillStyle = '#f9d84a';
        ctx.beginPath();
        ctx.arc(0, 0, s * 0.2, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, s * 0.18, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  },

  // 1 — Bold triangles blue/orange
  (ctx, size) => {
    const cols = ['#1e3a9e', '#e85a3a', '#2e55d4', '#f0f0f0'];
    const grid = 4;
    const s = size / grid;
    for (let r = 0; r < grid; r++) {
      for (let c = 0; c < grid; c++) {
        // upper-left triangle
        ctx.fillStyle = cols[(r + c) % cols.length];
        ctx.beginPath();
        ctx.moveTo(c * s, r * s);
        ctx.lineTo((c + 1) * s, r * s);
        ctx.lineTo(c * s, (r + 1) * s);
        ctx.closePath();
        ctx.fill();
        // lower-right triangle
        ctx.fillStyle = cols[(r + c + 2) % cols.length];
        ctx.beginPath();
        ctx.moveTo((c + 1) * s, r * s);
        ctx.lineTo((c + 1) * s, (r + 1) * s);
        ctx.lineTo(c * s, (r + 1) * s);
        ctx.closePath();
        ctx.fill();
      }
    }
  },

  // 2 — Grid / checkerboard blue
  (ctx, size) => {
    ctx.fillStyle = '#c2d8f0';
    ctx.fillRect(0, 0, size, size);
    const grid = 5;
    const s = size / grid;
    const pad = s * 0.1;
    for (let r = 0; r < grid; r++) {
      for (let c = 0; c < grid; c++) {
        // outer rect
        ctx.fillStyle = '#daeaf8';
        ctx.fillRect(c * s + pad, r * s + pad, s - pad * 2, s - pad * 2);
        ctx.strokeStyle = '#4a80cc';
        ctx.lineWidth = Math.max(1, size * 0.005);
        ctx.strokeRect(c * s + pad, r * s + pad, s - pad * 2, s - pad * 2);
        // inner square
        const inner = s * 0.55;
        const ox = c * s + (s - inner) / 2;
        const oy = r * s + (s - inner) / 2;
        ctx.fillStyle = '#4a80cc';
        ctx.fillRect(ox, oy, inner, inner);
      }
    }
  },

  // 3 — Soft pastel diamond / triangle
  (ctx, size) => {
    const cols = ['#c4b8dc', '#e8ccd8', '#aec4d8', '#d4e8f0'];
    const grid = 4;
    const s = size / grid;
    for (let r = 0; r < grid; r++) {
      for (let c = 0; c < grid; c++) {
        ctx.fillStyle = cols[(r * 3 + c) % cols.length];
        ctx.beginPath();
        ctx.moveTo(c * s, r * s);
        ctx.lineTo((c + 1) * s, (r + 0.5) * s);
        ctx.lineTo(c * s, (r + 1) * s);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = cols[(r + c + 1) % cols.length];
        ctx.beginPath();
        ctx.moveTo((c + 1) * s, r * s);
        ctx.lineTo((c + 1) * s, (r + 1) * s);
        ctx.lineTo(c * s, (r + 0.5) * s);
        ctx.closePath();
        ctx.fill();
      }
    }
  },

  // 4 — Muted floral gray-blue
  (ctx, size) => {
    ctx.fillStyle = '#8fa8b4';
    ctx.fillRect(0, 0, size, size);
    const positions = [
      [0.25, 0.25], [0.75, 0.25], [0.5, 0.6], [0.15, 0.7], [0.85, 0.7],
    ];
    for (const [fx, fy] of positions) {
      const x = fx * size;
      const y = fy * size;
      const r = size * 0.1;
      // petals
      for (let p = 0; p < 5; p++) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((p * Math.PI * 2) / 5);
        ctx.fillStyle = '#c8d8c0';
        ctx.beginPath();
        ctx.ellipse(0, -r * 1.1, r * 0.32, r * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      ctx.fillStyle = '#e8d8c0';
      ctx.beginPath();
      ctx.arc(x, y, r * 0.28, 0, Math.PI * 2);
      ctx.fill();
    }
  },

  // 5 — Purple diagonal halves
  (ctx, size) => {
    const cols = ['#b0a0cc', '#d4c8e8', '#9080b4', '#e8e0f0'];
    const grid = 3;
    const s = size / grid;
    for (let r = 0; r < grid; r++) {
      for (let c = 0; c < grid; c++) {
        ctx.fillStyle = cols[(r + c) % cols.length];
        ctx.beginPath();
        ctx.moveTo(c * s, r * s);
        ctx.lineTo((c + 1) * s, r * s);
        ctx.lineTo(c * s, (r + 1) * s);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = cols[(r + c + 1) % cols.length];
        ctx.beginPath();
        ctx.moveTo((c + 1) * s, r * s);
        ctx.lineTo((c + 1) * s, (r + 1) * s);
        ctx.lineTo(c * s, (r + 1) * s);
        ctx.closePath();
        ctx.fill();
      }
    }
  },

  // 6 — Warm terracotta checks
  (ctx, size) => {
    const cols = ['#c8602a', '#e8905a', '#f0c8a0', '#803818'];
    const grid = 4;
    const s = size / grid;
    for (let r = 0; r < grid; r++) {
      for (let c = 0; c < grid; c++) {
        ctx.fillStyle = cols[(r + c) % cols.length];
        ctx.fillRect(c * s, r * s, s, s);
      }
    }
  },

  // 7 — Dark navy geometric
  (ctx, size) => {
    ctx.fillStyle = '#101828';
    ctx.fillRect(0, 0, size, size);
    const grid = 4;
    const s = size / grid;
    const cols = ['#e8c840', '#e85a3a', '#4898d8', '#f0f0f0'];
    for (let r = 0; r < grid; r++) {
      for (let c = 0; c < grid; c++) {
        if ((r + c) % 2 === 0) {
          ctx.fillStyle = cols[(r + c) % cols.length];
          ctx.beginPath();
          ctx.arc(c * s + s / 2, r * s + s / 2, s * 0.35, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillStyle = cols[(r + c + 1) % cols.length];
          ctx.fillRect(c * s + s * 0.15, r * s + s * 0.15, s * 0.7, s * 0.7);
        }
      }
    }
  },
];

// ===== Carousel Logic =====

const track = document.getElementById('track');
const prevBtn = document.getElementById('prev');
const nextBtn = document.getElementById('next');

let offset = 0;

// Layout config: each slot has a size class and pixel size.
// On small screens we show fewer / smaller cards.
function getSlots() {
  const vw = window.innerWidth;
  const BASE = vw < 480 ? 80 : vw < 700 ? 100 : 130;
  if (vw < 480) {
    return [
      { cls: 'size-md', px: BASE * 0.65 },
      { cls: 'size-lg', px: BASE },
      { cls: 'size-lg', px: BASE },
      { cls: 'size-lg', px: BASE },
      { cls: 'size-md', px: BASE * 0.65 },
    ];
  }
  if (vw < 700) {
    return [
      { cls: 'size-sm', px: BASE * 0.5 },
      { cls: 'size-md', px: BASE * 0.75 },
      { cls: 'size-lg', px: BASE },
      { cls: 'size-lg', px: BASE },
      { cls: 'size-lg', px: BASE },
      { cls: 'size-md', px: BASE * 0.75 },
      { cls: 'size-sm', px: BASE * 0.5 },
    ];
  }
  return [
    { cls: 'size-sm', px: BASE * 0.45 },
    { cls: 'size-sm', px: BASE * 0.65 },
    { cls: 'size-md', px: BASE * 0.8 },
    { cls: 'size-lg', px: BASE },
    { cls: 'size-lg', px: BASE },
    { cls: 'size-lg', px: BASE },
    { cls: 'size-md', px: BASE * 0.8 },
    { cls: 'size-sm', px: BASE * 0.65 },
    { cls: 'size-sm', px: BASE * 0.45 },
  ];
}

function buildCarousel() {
  track.innerHTML = '';
  const slots = getSlots();
  slots.forEach((slot, i) => {
    const patternIndex = ((i + offset) % patternGenerators.length + patternGenerators.length) % patternGenerators.length;
    const px = Math.round(slot.px);

    const card = document.createElement('div');
    card.className = `pattern-card ${slot.cls}`;

    const canvas = document.createElement('canvas');
    canvas.width = px * 2;   
    canvas.height = px * 2;
    canvas.style.width = px + 'px';
    canvas.style.height = px + 'px';

    const ctx = canvas.getContext('2d');
    ctx.scale(2, 2);
    patternGenerators[patternIndex](ctx, px);

    card.appendChild(canvas);
    track.appendChild(card);
  });
}

prevBtn.addEventListener('click', () => { offset--; buildCarousel(); });
nextBtn.addEventListener('click', () => { offset++; buildCarousel(); });


let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(buildCarousel, 150);
});


buildCarousel();
